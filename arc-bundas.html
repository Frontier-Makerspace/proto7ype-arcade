<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ARC BUNDAS</title>
<style>
html,body{
  margin:0;
  background:#000;
  overflow:hidden;
}
canvas{display:block}
</style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const c = document.getElementById("c")
const ctx = c.getContext("2d")

function resize(){
  c.width = innerWidth
  c.height = innerHeight
}
window.addEventListener("resize", resize)
resize()

// Game states
let gameState = 'selection' // 'selection', 'playing', 'gameOver'
let playerMode = 1 // 1 or 2 players
let gameStartTime = 0
let paused=false
let scoreP1=0, scoreP2=0
let laserFlashP1=0, laserFlashP2=0
let gameOver=false
let p1Dead=false, p2Dead=false

const ship1={x:0,y:0,a:0,sp:3,color:"#0f0"}
const ship2={x:0,y:0,a:0,sp:3,color:"#f0f"}
const bulletsP1=[], bulletsP2=[], bundas=[], particles=[]

// Probe/Satellite
let probe = null
let lastProbeSpawn = 0
const probeSpawnDelay = 15000 // 15 seconds between probe spawns

let lastFireP1=0, lastFireP2=0
let lastLaserP1=0, lastLaserP2=0
const fireDelay=180, laserDelay=1500

function clamp(o,r=0){
  o.x=Math.max(r, Math.min(c.width-r,o.x))
  o.y=Math.max(r, Math.min(c.height-r,o.y))
}

function spawnMeteor(){
  const gameTime = performance.now() - gameStartTime
  const canSpawnLarge = gameTime > 60000 // After 1 minute
  
  // Decide if spawning large asteroid
  const isLarge = canSpawnLarge && Math.random() < 0.2
  
  // Spawn from edges
  const side = Math.floor(Math.random() * 4) // 0=top, 1=right, 2=bottom, 3=left
  let x, y, vx, vy
  
  switch(side){
    case 0: // top
      x = Math.random() * c.width
      y = -30
      vx = (Math.random() - 0.5) * 2
      vy = 1 + Math.random() * 2
      break
    case 1: // right
      x = c.width + 30
      y = Math.random() * c.height
      vx = -(1 + Math.random() * 2)
      vy = (Math.random() - 0.5) * 2
      break
    case 2: // bottom
      x = Math.random() * c.width
      y = c.height + 30
      vx = (Math.random() - 0.5) * 2
      vy = -(1 + Math.random() * 2)
      break
    case 3: // left
      x = -30
      y = Math.random() * c.height
      vx = 1 + Math.random() * 2
      vy = (Math.random() - 0.5) * 2
      break
  }
  
  const size = isLarge ? 50 + Math.random() * 30 : 20 + Math.random() * 20
  const health = isLarge ? 3 + Math.floor(Math.random() * 3) : 1
  const speed = isLarge ? 0.7 : 1
  
  bundas.push({
    x, y,
    vx: vx * speed,
    vy: vy * speed,
    s: size,
    health: health,
    maxHealth: health,
    isLarge: isLarge
  })
}

function spawnProbe(){
  if(probe) return // Only one at a time
  
  const gameTime = performance.now() - gameStartTime
  if(gameTime < 120000) return // Only after 2 minutes
  
  const now = performance.now()
  if(now - lastProbeSpawn < probeSpawnDelay) return
  
  // Random chance to spawn
  if(Math.random() < 0.3){
    lastProbeSpawn = now
    
    probe = {
      x: c.width/2,
      y: c.height/2,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      s: 40,
      health: 25,
      maxHealth: 25
    }
  }
}

function splitAsteroid(asteroid){
  const numSplits = 2 + Math.floor(Math.random() * 2) // 2 or 3 pieces
  
  for(let i=0; i<numSplits; i++){
    const angle = (Math.PI * 2 / numSplits) * i + Math.random() * 0.5
    const speed = 1.5 + Math.random()
    
    bundas.push({
      x: asteroid.x,
      y: asteroid.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      s: asteroid.s / 2,
      health: 1,
      maxHealth: 1,
      isLarge: false
    })
  }
}

function resetGame(){
  gameState = 'playing'
  gameStartTime = performance.now()
  
  ship1.x=playerMode === 1 ? c.width/2 : c.width/3
  ship1.y=c.height/2
  ship1.a=0
  
  ship2.x=c.width*2/3
  ship2.y=c.height/2
  ship2.a=0
  
  bulletsP1.length=bulletsP2.length=bundas.length=particles.length=0
  scoreP1=scoreP2=0
  p1Dead=p2Dead=false
  gameOver=false
  probe = null
  lastProbeSpawn = 0
  
  for(let i=0;i<6;i++) spawnMeteor()
}

function fire(player){
  const t=performance.now()
  const ship = player===1?ship1:ship2
  const bullets = player===1?bulletsP1:bulletsP2
  const lastFire = player===1?lastFireP1:lastFireP2
  const isDead = player===1?p1Dead:p2Dead
  
  if(isDead) return
  if(t-lastFire<fireDelay) return
  
  if(player===1) lastFireP1=t
  else lastFireP2=t
  
  bullets.push({
    x:ship.x+Math.cos(ship.a)*16,
    y:ship.y+Math.sin(ship.a)*16,
    a:ship.a,v:8
  })
}

function explode(x,y){
  for(let i=0;i<30;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:40
    })
  }
}

function shipExplosion(x,y){
  for(let i=0;i<100;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*12,
      vy:(Math.random()-0.5)*12,
      life:60
    })
  }
}

function fireLaser(player){
  const t=performance.now()
  const ship = player===1?ship1:ship2
  const lastLaser = player===1?lastLaserP1:lastLaserP2
  const isDead = player===1?p1Dead:p2Dead
  
  if(isDead) return
  if(t-lastLaser<laserDelay) return
  
  if(player===1){
    lastLaserP1=t
    laserFlashP1=6
  } else {
    lastLaserP2=t
    laserFlashP2=6
  }

  // Hit asteroids
  for(let i=bundas.length-1;i>=0;i--){
    const dx=bundas[i].x-ship.x
    const dy=bundas[i].y-ship.y
    const ang=Math.atan2(dy,dx)
    const diff=Math.abs(Math.atan2(Math.sin(ang-ship.a),Math.cos(ang-ship.a)))
    if(diff<0.12){
      bundas[i].health--
      explode(bundas[i].x,bundas[i].y)
      
      if(bundas[i].health <= 0){
        if(bundas[i].isLarge){
          splitAsteroid(bundas[i])
          if(player===1) scoreP1+=500
          else scoreP2+=500
        } else {
          if(player===1) scoreP1+=300
          else scoreP2+=300
        }
        bundas.splice(i,1)
      }
    }
  }
  
  // Hit probe
  if(probe){
    const dx=probe.x-ship.x
    const dy=probe.y-ship.y
    const ang=Math.atan2(dy,dx)
    const diff=Math.abs(Math.atan2(Math.sin(ang-ship.a),Math.cos(ang-ship.a)))
    if(diff<0.15){
      probe.health -= 2
      explode(probe.x,probe.y)
      
      if(probe.health <= 0){
        explode(probe.x,probe.y)
        shipExplosion(probe.x,probe.y)
        if(player===1) scoreP1+=5000
        else scoreP2+=5000
        probe = null
      }
    }
  }
}

function update(){
  if(paused || gameOver || gameState !== 'playing') return

  if(Math.random()<0.015) spawnMeteor()
  
  // Try to spawn probe irregularly
  if(Math.random() < 0.01) spawnProbe()
  
  // Check ship collisions with asteroids
  if(!p1Dead){
    for(let i=0;i<bundas.length;i++){
      const dx=bundas[i].x-ship1.x
      const dy=bundas[i].y-ship1.y
      const dist=Math.sqrt(dx*dx+dy*dy)
      if(dist<bundas[i].s/2+15){
        shipExplosion(ship1.x,ship1.y)
        p1Dead=true
        break
      }
    }
    
    // Check collision with probe
    if(probe){
      const dx=probe.x-ship1.x
      const dy=probe.y-ship1.y
      const dist=Math.sqrt(dx*dx+dy*dy)
      if(dist<probe.s/2+15){
        shipExplosion(ship1.x,ship1.y)
        p1Dead=true
      }
    }
  }
  
  if(!p2Dead && playerMode === 2){
    for(let i=0;i<bundas.length;i++){
      const dx=bundas[i].x-ship2.x
      const dy=bundas[i].y-ship2.y
      const dist=Math.sqrt(dx*dx+dy*dy)
      if(dist<bundas[i].s/2+15){
        shipExplosion(ship2.x,ship2.y)
        p2Dead=true
        break
      }
    }
    
    // Check collision with probe
    if(probe){
      const dx=probe.x-ship2.x
      const dy=probe.y-ship2.y
      const dist=Math.sqrt(dx*dx+dy*dy)
      if(dist<probe.s/2+15){
        shipExplosion(ship2.x,ship2.y)
        p2Dead=true
      }
    }
  }
  
  // Check if game over
  if(playerMode === 1 && p1Dead){
    gameOver=true
  } else if(playerMode === 2 && p1Dead && p2Dead){
    gameOver=true
  }

  // Update P1 bullets
  bulletsP1.forEach((b,i)=>{
    b.x+=Math.cos(b.a)*b.v
    b.y+=Math.sin(b.a)*b.v
    if(b.x<0||b.x>c.width||b.y<0||b.y>c.height)
      bulletsP1.splice(i,1)
  })
  
  // Update P2 bullets
  if(playerMode === 2){
    bulletsP2.forEach((b,i)=>{
      b.x+=Math.cos(b.a)*b.v
      b.y+=Math.sin(b.a)*b.v
      if(b.x<0||b.x>c.width||b.y<0||b.y>c.height)
        bulletsP2.splice(i,1)
    })
  }

  // Update asteroids
  bundas.forEach((o,i)=>{
    o.x+=o.vx
    o.y+=o.vy
    
    // Remove if off screen
    if(o.x<-100||o.x>c.width+100||o.y<-100||o.y>c.height+100){
      bundas.splice(i,1)
    }
  })
  
  // Update probe
  if(probe){
    probe.x += probe.vx
    probe.y += probe.vy
    
    // Bounce off edges
    if(probe.x - probe.s/2 < 0 || probe.x + probe.s/2 > c.width){
      probe.vx *= -1
      probe.x = Math.max(probe.s/2, Math.min(c.width - probe.s/2, probe.x))
    }
    if(probe.y - probe.s/2 < 0 || probe.y + probe.s/2 > c.height){
      probe.vy *= -1
      probe.y = Math.max(probe.s/2, Math.min(c.height - probe.s/2, probe.y))
    }
  }

  particles.forEach(p=>{
    p.x+=p.vx
    p.y+=p.vy
    p.life--
  })
  for(let i=particles.length-1;i>=0;i--){
    if(particles[i].life<=0) particles.splice(i,1)
  }

  // P1 bullets vs asteroids
  for(let i=bundas.length-1;i>=0;i--){
    for(let j=bulletsP1.length-1;j>=0;j--){
      const dx=bundas[i].x-bulletsP1[j].x
      const dy=bundas[i].y-bulletsP1[j].y
      if(dx*dx+dy*dy<bundas[i].s*bundas[i].s){
        bundas[i].health--
        explode(bundas[i].x,bundas[i].y)
        bulletsP1.splice(j,1)
        
        if(bundas[i].health <= 0){
          if(bundas[i].isLarge){
            splitAsteroid(bundas[i])
            scoreP1+=500
          } else {
            scoreP1+=100
          }
          bundas.splice(i,1)
        }
        break
      }
    }
  }
  
  // P1 bullets vs probe
  if(probe){
    for(let j=bulletsP1.length-1;j>=0;j--){
      const dx=probe.x-bulletsP1[j].x
      const dy=probe.y-bulletsP1[j].y
      if(dx*dx+dy*dy<probe.s*probe.s){
        probe.health--
        explode(probe.x,probe.y)
        bulletsP1.splice(j,1)
        
        if(probe.health <= 0){
          shipExplosion(probe.x,probe.y)
          scoreP1+=5000
          probe = null
        }
        break
      }
    }
  }
  
  // P2 bullets vs asteroids
  if(playerMode === 2){
    for(let i=bundas.length-1;i>=0;i--){
      for(let j=bulletsP2.length-1;j>=0;j--){
        const dx=bundas[i].x-bulletsP2[j].x
        const dy=bundas[i].y-bulletsP2[j].y
        if(dx*dx+dy*dy<bundas[i].s*bundas[i].s){
          bundas[i].health--
          explode(bundas[i].x,bundas[i].y)
          bulletsP2.splice(j,1)
          
          if(bundas[i].health <= 0){
            if(bundas[i].isLarge){
              splitAsteroid(bundas[i])
              scoreP2+=500
            } else {
              scoreP2+=100
            }
            bundas.splice(i,1)
          }
          break
        }
      }
    }
    
    // P2 bullets vs probe
    if(probe){
      for(let j=bulletsP2.length-1;j>=0;j--){
        const dx=probe.x-bulletsP2[j].x
        const dy=probe.y-bulletsP2[j].y
        if(dx*dx+dy*dy<probe.s*probe.s){
          probe.health--
          explode(probe.x,probe.y)
          bulletsP2.splice(j,1)
          
          if(probe.health <= 0){
            shipExplosion(probe.x,probe.y)
            scoreP2+=5000
            probe = null
          }
          break
        }
      }
    }
  }

  if(!p1Dead) clamp(ship1,20)
  if(!p2Dead && playerMode === 2) clamp(ship2,20)
}

function drawShip(ship, isDead){
  if(isDead) return
  ctx.save()
  ctx.translate(ship.x,ship.y)
  ctx.rotate(ship.a)
  ctx.beginPath()
  ctx.moveTo(20,0)
  ctx.lineTo(-14,-10)
  ctx.lineTo(-8,0)
  ctx.lineTo(-14,10)
  ctx.closePath()
  ctx.strokeStyle=ship.color
  ctx.lineWidth=2
  ctx.stroke()
  ctx.restore()
}

function drawInstructions(){
  const lines = playerMode === 1 ? [
    "P1: Joystick=Move/Rotate",
    "P1: Btn8=LASER Btn9=Gun"
  ] : [
    "P1: Joystick=Move/Rotate",
    "P1: Btn8=LASER Btn9=Gun",
    "P2: Joystick=Move/Rotate",
    "P2: Btn2=LASER Btn3=Gun"
  ]
  ctx.font="13px monospace"
  ctx.fillStyle="#ff0"
  lines.forEach((t,i)=>{
    ctx.fillText(t,c.width-220,25+i*17)
  })
}

function drawSelectionScreen(){
  ctx.fillStyle="#000"
  ctx.fillRect(0,0,c.width,c.height)
  
  // Title
  ctx.fillStyle="#0ff"
  ctx.font="80px monospace"
  ctx.textAlign="center"
  ctx.fillText("ARC BUNDAS",c.width/2,c.height/3)
  
  // Options
  ctx.font="40px monospace"
  ctx.fillStyle="#0f0"
  ctx.fillText("1 PLAYER",c.width/2,c.height/2)
  
  ctx.fillStyle="#f0f"
  ctx.fillText("2 PLAYERS",c.width/2,c.height/2+60)
  
  // Instructions
  ctx.font="20px monospace"
  ctx.fillStyle="#ff0"
  ctx.fillText("PRESS 1P SELECT OR 2P SELECT",c.width/2,c.height/2+140)
  
  ctx.textAlign="left"
  
  // scanlines
  ctx.fillStyle="rgba(0,0,0,0.12)"
  for(let y=0;y<c.height;y+=4)
    ctx.fillRect(0,y,c.width,1)
}

function draw(){
  if(gameState === 'selection'){
    drawSelectionScreen()
    return
  }
  
  ctx.fillStyle=`rgba(0,0,0,${(laserFlashP1||laserFlashP2)?0.12:0.35})`
  ctx.fillRect(0,0,c.width,c.height)

  if(laserFlashP1){
    ctx.strokeStyle="#0ff"
    ctx.lineWidth=10
    ctx.beginPath()
    ctx.moveTo(ship1.x,ship1.y)
    ctx.lineTo(
      ship1.x+Math.cos(ship1.a)*2000,
      ship1.y+Math.sin(ship1.a)*2000
    )
    ctx.stroke()
    laserFlashP1--
  }
  
  if(laserFlashP2 && playerMode === 2){
    ctx.strokeStyle="#f8f"
    ctx.lineWidth=10
    ctx.beginPath()
    ctx.moveTo(ship2.x,ship2.y)
    ctx.lineTo(
      ship2.x+Math.cos(ship2.a)*2000,
      ship2.y+Math.sin(ship2.a)*2000
    )
    ctx.stroke()
    laserFlashP2--
  }

  drawShip(ship1, p1Dead)
  if(playerMode === 2) drawShip(ship2, p2Dead)

  ctx.fillStyle="#aff"
  bulletsP1.forEach(b=>ctx.fillRect(b.x,b.y,3,3))
  
  if(playerMode === 2){
    ctx.fillStyle="#faf"
    bulletsP2.forEach(b=>ctx.fillRect(b.x,b.y,3,3))
  }

  // Draw asteroids
  bundas.forEach(o=>{
    ctx.strokeStyle=o.isLarge?"#f80":"#888"
    ctx.lineWidth=o.isLarge?3:2
    ctx.strokeRect(o.x-o.s/2,o.y-o.s/2,o.s,o.s)
    
    // Health bar for large asteroids
    if(o.isLarge && o.health < o.maxHealth){
      const barWidth = o.s
      const barHeight = 4
      const healthPct = o.health / o.maxHealth
      
      ctx.fillStyle="#f00"
      ctx.fillRect(o.x-barWidth/2,o.y-o.s/2-10,barWidth,barHeight)
      ctx.fillStyle="#0f0"
      ctx.fillRect(o.x-barWidth/2,o.y-o.s/2-10,barWidth*healthPct,barHeight)
    }
  })
  
  // Draw probe
  if(probe){
    ctx.strokeStyle="#ff0"
    ctx.lineWidth=3
    ctx.beginPath()
    ctx.arc(probe.x,probe.y,probe.s/2,0,Math.PI*2)
    ctx.stroke()
    
    // Health bar
    const barWidth = 80
    const barHeight = 6
    const healthPct = probe.health / probe.maxHealth
    
    ctx.fillStyle="#f00"
    ctx.fillRect(probe.x-barWidth/2,probe.y-probe.s/2-15,barWidth,barHeight)
    ctx.fillStyle="#0f0"
    ctx.fillRect(probe.x-barWidth/2,probe.y-probe.s/2-15,barWidth*healthPct,barHeight)
    
    // Label
    ctx.font="10px monospace"
    ctx.fillStyle="#ff0"
    ctx.textAlign="center"
    ctx.fillText("PROBE",probe.x,probe.y-probe.s/2-20)
    ctx.textAlign="left"
  }

  ctx.fillStyle="#ff0"
  particles.forEach(p=>{
    ctx.globalAlpha=p.life/40
    ctx.fillRect(p.x,p.y,2,2)
    ctx.globalAlpha=1
  })

  // Scores and timer
  ctx.font="20px monospace"
  ctx.fillStyle="#0f0"
  ctx.fillText("P1: "+scoreP1,20,25)
  
  if(playerMode === 2){
    ctx.fillStyle="#f0f"
    ctx.textAlign="right"
    ctx.fillText("P2: "+scoreP2,c.width-20,25)
    ctx.textAlign="left"
  }
  
  // Game time
  const gameTime = Math.floor((performance.now() - gameStartTime) / 1000)
  ctx.fillStyle="#0ff"
  ctx.textAlign="center"
  ctx.font="16px monospace"
  ctx.fillText("TIME: "+gameTime+"s",c.width/2,25)
  ctx.textAlign="left"
  
  // Player death indicators
  if(p1Dead && !gameOver){
    ctx.fillStyle="#f00"
    ctx.font="16px monospace"
    ctx.fillText("P1 DEAD",20,50)
  }
  if(p2Dead && !gameOver && playerMode === 2){
    ctx.fillStyle="#f00"
    ctx.font="16px monospace"
    ctx.textAlign="right"
    ctx.fillText("P2 DEAD",c.width-20,50)
    ctx.textAlign="left"
  }

  // scanlines
  ctx.fillStyle="rgba(0,0,0,0.12)"
  for(let y=0;y<c.height;y+=4)
    ctx.fillRect(0,y,c.width,1)

  if(!gameOver) drawInstructions()
  
  // Game over screen
  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,0.7)"
    ctx.fillRect(0,0,c.width,c.height)
    
    ctx.fillStyle="#f00"
    ctx.font="80px monospace"
    ctx.textAlign="center"
    ctx.fillText("GAME OVER",c.width/2,c.height/2-80)
    
    if(playerMode === 1){
      ctx.fillStyle="#0f0"
      ctx.font="40px monospace"
      ctx.fillText("SCORE: "+scoreP1,c.width/2,c.height/2-10)
    } else {
      ctx.fillStyle="#0f0"
      ctx.font="30px monospace"
      ctx.fillText("P1 SCORE: "+scoreP1,c.width/2,c.height/2-20)
      
      ctx.fillStyle="#f0f"
      ctx.font="30px monospace"
      ctx.fillText("P2 SCORE: "+scoreP2,c.width/2,c.height/2+20)
    }
    
    ctx.fillStyle="#ff0"
    ctx.font="25px monospace"
    ctx.fillText("PRESS START TO RESTART",c.width/2,c.height/2+80)
    
    ctx.fillStyle="#0ff"
    ctx.font="20px monospace"
    ctx.fillText("PRESS COIN TO RETURN TO MENU",c.width/2,c.height/2+120)
    
    ctx.textAlign="left"
  }
}

let k3Pressed = false
let btn8Pressed = false
let btn9Pressed = false

function handleGamepad0(){
  const gp = navigator.getGamepads()[0]
  if(!gp) return

  // START button (BTN 3) - Restart game when game over
  const k3Button = gp.buttons[3]?.pressed
  if(k3Button && !k3Pressed && gameOver){
    k3Pressed = true
    gameOver = false
    gameState = 'selection'
    return
  }
  if(!k3Button) k3Pressed = false
  
  // COIN button (BTN 2) - Return to menu when game over
  if(gp.buttons[2]?.pressed && gameOver){
    window.location.href = 'index.html'
    return
  }
  
  if(gameState !== 'playing' || gameOver || p1Dead) return

  const ax=gp.axes[0], ay=gp.axes[1]
  const dead=0.18
  
  // Joystick X-axis: Rotate ship
  if(Math.abs(ax)>dead) ship1.a+=ax*0.05

  // Joystick Y-axis: Move forward/backward
  if(Math.abs(ay)>dead){
    ship1.x += Math.cos(ship1.a) * (-ay) * ship1.sp
    ship1.y += Math.sin(ship1.a) * (-ay) * ship1.sp
  }
  
  // UP button (BTN 7) - Move forward
  if(gp.buttons[7]?.pressed){
    ship1.x += Math.cos(ship1.a) * ship1.sp
    ship1.y += Math.sin(ship1.a) * ship1.sp
  }
  
  // DOWN button (BTN 4) - Move backward
  if(gp.buttons[4]?.pressed){
    ship1.x -= Math.cos(ship1.a) * ship1.sp
    ship1.y -= Math.sin(ship1.a) * ship1.sp
  }
  
  // LEFT button (BTN 5) - Strafe left
  if(gp.buttons[5]?.pressed){
    ship1.x += Math.cos(ship1.a - Math.PI/2) * ship1.sp
    ship1.y += Math.sin(ship1.a - Math.PI/2) * ship1.sp
  }
  
  // RIGHT button (BTN 6) - Strafe right
  if(gp.buttons[6]?.pressed){
    ship1.x += Math.cos(ship1.a + Math.PI/2) * ship1.sp
    ship1.y += Math.sin(ship1.a + Math.PI/2) * ship1.sp
  }

  // ACTION 1 (BTN 8) - Fire LASER
  if(gp.buttons[8]?.pressed) {
    fireLaser(1)
  }
  
  // ACTION 2 (BTN 9) - Fire bullets
  if(gp.buttons[9]?.pressed) {
    fire(1)
  }
}

function handleGamepad1(){
  const gp = navigator.getGamepads()[1]
  if(!gp) return
  
  // Selection screen - choose mode
  if(gameState === 'selection'){
    const btn8 = gp.buttons[8]?.pressed
    const btn9 = gp.buttons[9]?.pressed
    
    if(btn8 && !btn8Pressed){
      btn8Pressed = true
      playerMode = 1
      resetGame()
    }
    if(btn9 && !btn9Pressed){
      btn9Pressed = true
      playerMode = 2
      resetGame()
    }
    
    if(!btn8) btn8Pressed = false
    if(!btn9) btn9Pressed = false
    return
  }
  
  if(playerMode !== 2 || gameOver || p2Dead) return

  const ax=gp.axes[0], ay=gp.axes[1]
  const dead=0.18
  
  // Joystick X-axis: Rotate ship
  if(Math.abs(ax)>dead) ship2.a+=ax*0.05

  // Joystick Y-axis: Move forward/backward
  if(Math.abs(ay)>dead){
    ship2.x += Math.cos(ship2.a) * (-ay) * ship2.sp
    ship2.y += Math.sin(ship2.a) * (-ay) * ship2.sp
  }
  
  // UP button (BTN 7) - Move forward
  if(gp.buttons[7]?.pressed){
    ship2.x += Math.cos(ship2.a) * ship2.sp
    ship2.y += Math.sin(ship2.a) * ship2.sp
  }
  
  // DOWN button (BTN 4) - Move backward
  if(gp.buttons[4]?.pressed){
    ship2.x -= Math.cos(ship2.a) * ship2.sp
    ship2.y -= Math.sin(ship2.a) * ship2.sp
  }
  
  // LEFT button (BTN 5) - Strafe left
  if(gp.buttons[5]?.pressed){
    ship2.x += Math.cos(ship2.a - Math.PI/2) * ship2.sp
    ship2.y += Math.sin(ship2.a - Math.PI/2) * ship2.sp
  }
  
  // RIGHT button (BTN 6) - Strafe right
  if(gp.buttons[6]?.pressed){
    ship2.x += Math.cos(ship2.a + Math.PI/2) * ship2.sp
    ship2.y += Math.sin(ship2.a + Math.PI/2) * ship2.sp
  }

  // ACTION 1 (BTN 2) - Fire LASER
  if(gp.buttons[2]?.pressed) {
    fireLaser(2)
  }
  
  // ACTION 2 (BTN 3) - Fire bullets
  if(gp.buttons[3]?.pressed) {
    fire(2)
  }
}

function loop(){
  handleGamepad0()
  handleGamepad1()
  update()
  draw()
  requestAnimationFrame(loop)
}

loop()
</script>
</body>
</html>
